'use client';

import React, { useMemo, useState } from 'react';

/** =========================================================
 * 0) è«–æ–‡è¨­å®šï¼šæ¼”ç¿’ D-Day çœŸå€¼è¡¨ (åŸºæº–éŒ¨é»)
 * ä¿®æ­£ä¾æ“šï¼šæ‚¨å‰›å‰›æä¾›çš„æ­£ç¢ºæ­·å²æ—¥æœŸ
 * ========================================================= */
const EXERCISE_CONFIG: Record<string, string> = {
  "2022ç’°å°è»æ¼”": "2022-08-04",           // ä¿®æ­£ï¼š8/4
  "2023è¯åˆåˆ©åŠ": "2023-04-08",           // ç¶­æŒ
  "2023æµ·ç©ºè¯åˆæˆ°å‚™è­¦å·¡æ¼”ç·´": "2023-08-20", // ä¿®æ­£ï¼š8/20
  "è¯åˆåˆ©åŠ2024A": "2024-05-23",          // ç¶­æŒ
  "è¯åˆåˆ©åŠ2024B": "2024-10-14",          // ç¶­æŒ
  "æµ·å³½é›·éœ†2025": "2025-04-01",           // ä¿®æ­£ï¼š4/1
  "æ­£ç¾©ä½¿å‘½2025": "2025-12-29",           // ä¿®æ­£ï¼š12/29
};

/** =========================================================
 * 1) å­—å…¸èˆ‡è¨­å®š (ä¿æŒä¸è®Š)
 * ========================================================= */
const BAG_JUSTIFY = [
  "ç¶­è­·","æè¡›","å …æŒ","åå°","éåˆ¶","ä¸æ‰¿è«¾æ”¾æ£„","ä¸æ‰¿è«¾æ”¾æ£„ï¼ˆæ­¦åŠ›ï¼‰","æ­¦åŠ›","è‡´åŠ›æ–¼","å¯¦ç¾",
  "ä¸»æ¬Š","é ˜åœŸå®Œæ•´","ä¸€ä¸­åŸå‰‡","ä¹äºŒå…±è­˜","å’Œå¹³çµ±ä¸€","ä¸€åœ‹å…©åˆ¶","æ ¸å¿ƒåˆ©ç›Š","æ°‘æ—å¾©èˆˆ","æ­·å²ä»»å‹™",
  "ç¥–åœ‹çµ±ä¸€","åº•ç·š","ç´…ç·š","åŸºæœ¬æ–¹é‡","å …å®š","å …æ±º","ä¸å¯å‹•æ–","çŸ¢å¿—ä¸æ¸","ä¸€è²«","æ˜ç¢º",
  "æ­£ç•¶","åˆæ³•","å …å¼·","æ„å¿—","å …å¼·ï¼ˆæ„å¿—ï¼‰"
];
const BAG_DETER = [
  "åš´æ­£è­¦å‘Š","åš´æ‡²","ç²‰ç¢","æ¸…ç®—","æ‰“æ“Š","ç©ç«","è‡ªç„š","åŸ‹è‘¬","æŒ‘é‡","åˆ†è£‚","å‹¾é€£","æ³¨å®šå¤±æ•—",
  "å¾Œæœè‡ªè² ","æ­»è·¯ä¸€æ¢","ä»˜å‡ºä»£åƒ¹","é ­ç ´è¡€æµ","å¦„æƒ³","ç½é›£æ€§å¾Œæœ","é›·éœ†ä¹‹å‹¢","çµ•ä¸å§‘æ¯",
  "è¬åŠ«ä¸å¾©","æ­·å²ç½ªäºº","å‹¿è¬‚è¨€ä¹‹ä¸é ","å¿…å°‡","ä¸€å®šæœƒ","ä¸å¾—ä¸","ä¸æƒœä¸€åˆ‡ä»£åƒ¹","ä»»ä½•æ™‚å€™","ä»»ä½•å½¢å¼"
];
const BAG_ESCALATE = [
  "æ¼”ç·´","æ¼”ç¿’","è¯åˆæ¼”è¨“","è­¦å·¡","æˆ°å‚™","å°é–","å¯¦å½ˆå°„æ“Š","æŠµè¿‘","æ‡¾å£“","å¸¸æ…‹åŒ–","å·¡èˆª","è¶Šç·š",
  "ç«‹é«”","å…¨å¤©å€™","é€²ä¸€æ­¥","å‡ç´š","æ¡å–","æ¡å–ï¼ˆå¿…è¦ï¼‰è¡Œå‹•","å¿…è¦è¡Œå‹•","ååˆ¶","æ‹­ç›®ä»¥å¾…","å¥‰é™ªåˆ°åº•",
  "çµ•ä¸åè¦–","åæ“Š","åŠ å¤§","åŠ å¤§ï¼ˆåŠ›åº¦ï¼‰","å°å³¶å‘¨é‚Š","æµ·ç©ºåŸŸ","è¶Šéä¸­ç·š","å¤šè»å…µç¨®","å…¨è¦ç´ ",
  "é—œé–€æ‰“ç‹—","å€åŸŸæ‹’æ­¢"
];
const EXERCISE_ORDER = [
  "2022ç’°å°è»æ¼”",
  "2023è¯åˆåˆ©åŠ",
  "2023æµ·ç©ºè¯åˆæˆ°å‚™è­¦å·¡æ¼”ç·´",
  "è¯åˆåˆ©åŠ2024A",
  "è¯åˆåˆ©åŠ2024B",
  "æµ·å³½é›·éœ†2025",
  "æ­£ç¾©ä½¿å‘½2025",
];
const TAIWAN_LEXICON = [
  "å°ç£","å°æ¹¾","è‡ºç£","å°æµ·","è‡ºæµ·","å°æ¹¾åœ°åŒº","å°å²›","å°å³¶",
  "å…©å²¸","ä¸¤å²¸","æµ·å³½å…©å²¸","æµ·å³¡ä¸¤å²¸","ä¸­ç·š","ä¸­çº¿","å°å³¶å‘¨é‚Š","å°å²›å‘¨è¾¹"
];

/** ====== å°å·¥å…· ====== */
function esc(s: string){ return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }
function uniqStr(arr: string[]) {
  const s = new Set<string>();
  for (const x of arr) {
    const v = String(x || "").trim();
    if (v) s.add(v);
  }
  return Array.from(s);
}
function makeRe(list: string[]){ return new RegExp(uniqStr(list).map(esc).join("|"), "g"); }
function stripBom(s: string){ return s.replace(/^\uFEFF/, ""); }
function toYMD(d: Date){
  return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate())).toISOString().slice(0,10);
}

// å¼·åŒ–ç‰ˆæ—¥æœŸè§£æ (å°æ‡‰æ‚¨çš„ CSV æ ¼å¼ 2022-07-05)
function parseYMD(s: string){
  let t = String(s ?? "").trim().replace(/["']/g,"");
  if (t.includes(" ")) t = t.split(" ")[0];
  if (t.includes("T")) t = t.split("T")[0];
  const m = t.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/);
  if (!m) return null;
  const d = new Date(Date.UTC(+m[1], +m[2]-1, +m[3]));
  return isNaN(d.getTime()) ? null : d;
}
function addDays(d: Date, n: number){
  const x = new Date(d);
  x.setUTCDate(x.getUTCDate()+n);
  return x;
}
function rangeDays(a: Date, b: Date){
  const out: string[] = [];
  for(let d=new Date(a); d<=b; d=addDays(d,1)) out.push(toYMD(d));
  return out;
}
// ğŸ”¥ æ ¸å¿ƒï¼šè¨ˆç®—å…©å€‹æ—¥æœŸå­—ä¸²çš„å¤©æ•¸å·® (d2 - d1)
function getDaysDiff(d1: string, d2: string) {
  const t1 = parseYMD(d1)?.getTime() || 0;
  const t2 = parseYMD(d2)?.getTime() || 0;
  return Math.round((t2 - t1) / (1000 * 3600 * 24));
}

// Z-Score
function zScore(arr: number[]) {
  const n = arr.length;
  if (n === 0) return [];
  const mean = arr.reduce((a, b) => a + b, 0) / n;
  const variance = arr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
  const std = Math.sqrt(variance);
  if (std === 0) return arr.map(() => 0);
  return arr.map(v => (v - mean) / std);
}

function movingAvg(arr: number[], k: number){
  if (k<=1) return arr.slice();
  const out: number[] = new Array(arr.length).fill(0);
  let sum = 0;
  for (let i=0;i<arr.length;i++){
    sum += arr[i];
    if (i>=k) sum -= arr[i-k];
    out[i] = i>=k-1 ? sum/k : sum/(i+1);
  }
  return out;
}
function shift(arr: number[], lead: number){
  const n = arr.length;
  const out = new Array(n).fill(0);
  for(let i=0;i<n;i++){
    const j = i + lead;
    if (j>=0 && j<n) out[i] = arr[j];
  }
  return out;
}
function minMaxNormByWindow(series: number[], dates: string[], winStart: string, winEnd: string){
  let lo = +Infinity, hi = -Infinity;
  for (let i=0;i<dates.length;i++){
    if (dates[i]>=winStart && dates[i]<=winEnd){
      if (series[i]<lo) lo = series[i];
      if (series[i]>hi) hi = series[i];
    }
  }
  if (!isFinite(lo) || !isFinite(hi) || hi===lo) {
    lo = Math.min(...series);
    hi = Math.max(...series);
    if (hi===lo){ return series.map(_=>0.5); }
  }
  const span = hi - lo;
  return series.map(v => Math.max(0, Math.min(1, (v - lo) / span)));
}

/** ====== é—œéµè©ä¸Šè‰²èˆ‡æ–·å¥ (ä¿æŒä¸è®Š) ====== */
const TW_RE = makeRe(TAIWAN_LEXICON);
function splitSentences(text: string){
  const s = String(text ?? "").replace(/\r\n/g, "\n").replace(/\s+/g, " ").trim();
  if (!s) return [];
  const parts = s.split(/(?<=[ã€‚ï¼ï¼Ÿ!?ï¼›;])\s+|\n+/g).map(x=>x.trim()).filter(Boolean);
  return parts.length<=1 ? s.split(/[ï¼Œ,ã€]\s*/g).map(x=>x.trim()).filter(Boolean) : parts;
}
function taiwanIssueSentences(text: string){
  return splitSentences(text).filter(s => TW_RE.test(s));
}

type TokCat = 'justify' | 'deter' | 'escalate';
type HiTok = { t: string; cat: TokCat; bg: string; fg: string; prio: number };
const HILITE_TOKENS: HiTok[] = (() => {
  const prio = { escalate: 3, deter: 2, justify: 1 } as const;
  const m = new Map<string, HiTok>();
  const put = (t: string, cat: TokCat) => {
    const token = String(t||"").trim();
    if (!token) return;
    const style = cat === 'escalate' ? { bg:'#fee2e2', fg:'#991b1b' } :
                  cat === 'deter'    ? { bg:'#fef3c7', fg:'#92400e' } :
                                       { bg:'#dcfce7', fg:'#065f46' };
    const cur: HiTok = { t: token, cat, ...style, prio: prio[cat] };
    const old = m.get(token);
    if (!old || cur.prio > old.prio) m.set(token, cur);
  };
  BAG_JUSTIFY.forEach(t=>put(t,'justify'));
  BAG_DETER.forEach(t=>put(t,'deter'));
  BAG_ESCALATE.forEach(t=>put(t,'escalate'));
  return Array.from(m.values()).sort((a,b)=> b.t.length - a.t.length);
})();

function highlightSentence3Colors(s: string): React.ReactNode[] {
  const out: React.ReactNode[] = [];
  const text = s || "";
  const n = text.length;
  let i = 0; let key = 0;
  const startsWithAt = (str: string, sub: string, pos: number) => str.substring(pos, pos + sub.length) === sub;
  const bestAt = (pos:number): HiTok | null => {
    for (const tok of HILITE_TOKENS) if (startsWithAt(text, tok.t, pos)) return tok;
    return null;
  };
  const findNextMatch = (from: number): number => {
    let next = n;
    for (const tok of HILITE_TOKENS) {
      const j = text.indexOf(tok.t, from);
      if (j !== -1 && j < next) next = j;
    }
    return next;
  };
  while (i < n) {
    const best = bestAt(i);
    if (best) {
      out.push(<span key={key++} style={{background: best.bg, color: best.fg, padding: "0 2px", borderRadius: 4, margin: "0 1px"}}>{best.t}</span>);
      i += best.t.length; continue;
    }
    const next = findNextMatch(i + 1);
    out.push(<span key={key++}>{text.slice(i, next)}</span>);
    i = next;
  }
  return out;
}

/** =========================================================
 * 5) è§£æ CSV (ä¿æŒä¸è®Š)
 * ========================================================= */
function parseTable(text: string){
  const raw = stripBom(text.replace(/\r\n/g, "\n"));
  const lines = raw.split("\n").filter(l => l.length>0);
  if (lines.length===0) return {rows:[], headers:[], delim:","};
  const delim = lines[0].includes("\t") ? "\t" : ",";
  const parseLine = (line:string) => {
    const out:string[]=[]; let cur="",q=false;
    for(let i=0;i<line.length;i++){
      const c=line[i];
      if(q){ if(c==='"'){ if(line[i+1]==='"'){cur+='"';i++;} else q=false; }else cur+=c; }
      else{ if(c==='"')q=true; else if(c===delim){out.push(cur);cur="";} else cur+=c; }
    }
    out.push(cur); return out;
  };
  const headers = parseLine(lines[0]).map(h => stripBom(h).replace(/(^"|"$)/g,""));
  const rows = [];
  for(let i=1;i<lines.length;i++){
    const cols = parseLine(lines[i]);
    if(cols.length===0) continue;
    const obj:any={};
    for(let j=0;j<headers.length;j++) obj[headers[j]]=(cols[j]??"").replace(/(^"|"$)/g,"");
    rows.push(obj);
  }
  return {rows, headers, delim};
}

function findKey(obj:any, cands:string[]){
  const keys = Object.keys(obj).map(k=>stripBom(k));
  for (const c of cands){
    const hit = keys.find(k => k.toLowerCase()===c.toLowerCase());
    if (hit) return hit;
  }
  return null;
}
function findKeyFromArray(rows:any[], cands:string[]){
  for (const r of rows){
    const k = findKey(r, cands);
    if (k) return k;
  }
  return cands[0];
}

/** =========================================================
 * ä¸»å…ƒä»¶
 * ========================================================= */
export default function Page(){
  const [fileName, setFileName] = useState<string>("");
  const [rows, setRows] = useState<any[]>([]);
  const [headers, setHeaders] = useState<string[]>([]);
  const [loading, setLoading] = useState(false);
  const [errorMsg, setErrorMsg] = useState("");
  const [visibleCount, setVisibleCount] = useState(100);

  // åƒæ•¸
  const [w1, setW1] = useState(1.0);
  const [w2, setW2] = useState(1.5);
  const [w3, setW3] = useState(2.0);
  const [ma, setMA] = useState(3);
  const [lead, setLead] = useState(0);

  const [selectedExercise, setSelectedExercise] = useState<string>("å…¨éƒ¨");
  const [showNci, setShowNci] = useState(true);
  const [showJ, setShowJ] = useState(true);
  const [showD, setShowD] = useState(true);
  const [showE, setShowE] = useState(true);
  const [winStart, setWinStart] = useState<string>("");
  const [winEnd, setWinEnd] = useState<string>("");

  /** è®€æª” */
  function onPickFile(e: React.ChangeEvent<HTMLInputElement>){
    const f = e.target.files?.[0];
    if (!f) return;
    setLoading(true); setErrorMsg(""); setFileName(f.name);
    const fr = new FileReader();
    fr.onload = () => {
      try {
        const text = typeof fr.result === 'string' ? fr.result : new TextDecoder("utf-8").decode(fr.result as ArrayBuffer);
        const {rows, headers} = parseTable(text);
        if (rows.length === 0) setErrorMsg("æª”æ¡ˆç‚ºç©ºæˆ–æ ¼å¼éŒ¯èª¤");
        else {
           setRows(rows); setHeaders(headers); setSelectedExercise("å…¨éƒ¨"); setVisibleCount(100);
        }
      } catch (err) { setErrorMsg("è§£æå¤±æ•—"); } finally { setLoading(false); }
    };
    fr.readAsText(f);
  }

  // è‡ªå‹•åµæ¸¬æ¬„ä½
  const keys = useMemo(()=>{
    if (rows.length === 0) return { kEx:"", kDate:"", kSrc:"", kText:"", kManual:"", kAuto:"" };
    return {
       kEx: findKeyFromArray(rows, ["æ‰€å±¬è»æ¼”","å†›æ¼”","äº‹ä»¶","event","exercise","exercise_name","campaign"]),
       kDate: findKeyFromArray(rows, ["date","æ—¥æœŸ","Date"]),
       kSrc: findKeyFromArray(rows, ["source","ä¾†æº","Media","media"]),
       kText: findKeyFromArray(rows, ["text","å…§å®¹","content","Content","å…§æ–‡"]),
       kManual: findKeyFromArray(rows, ["äººå·¥æ ¡æ­£", "Manual_Label", "Manual"]),
       kAuto: findKeyFromArray(rows, ["Signal_Type", "BERT_Label", "Signal"])
    };
  },[rows]);

  // 1. è³‡æ–™æ¸…ç†
  const cleanedRows = useMemo(()=>{
    if(rows.length===0) return [];
    const set7 = new Set(EXERCISE_ORDER);
    return rows.filter(r => set7.has(String(r[kEx] ?? "").trim()));
  }, [rows, keys]);

  const filteredRows = useMemo(()=>{
    if(cleanedRows.length===0) return [];
    if(selectedExercise==="å…¨éƒ¨") return cleanedRows;
    return cleanedRows.filter(r=>String(r[keys.kEx]??"").trim()===selectedExercise);
  }, [cleanedRows, selectedExercise, keys]);

  // 2. æ ¸å¿ƒé‹ç®—
  const preview = useMemo(()=>{
    if (filteredRows.length===0) return null;

    const datesSet = new Set(filteredRows.map(r=>toYMD(parseYMD(r[keys.kDate])||new Date())));
    const dates = Array.from(datesSet).sort();
    const minD = parseYMD(dates[0])!, maxD = parseYMD(dates[dates.length-1])!;
    const allDays = rangeDays(minD, maxD);
    
    const counts = allDays.map(d => ({j:0, d:0, e:0}));
    const dayMap = new Map(allDays.map((d,i)=>[d, i]));
    
    for(const r of filteredRows){
       const d = toYMD(parseYMD(r[keys.kDate])||new Date());
       const idx = dayMap.get(d);
       if(idx===undefined) continue;
       
       const rawMan = String(r[keys.kManual]??"").trim();
       const rawAuto = String(r[keys.kAuto]??"").trim();
       let typeStr = (rawMan && rawMan.toLowerCase()!=="nan") ? rawMan : rawAuto;
       let val = 0;
       if (!isNaN(parseFloat(typeStr))) val = parseInt(typeStr, 10);
       else if (typeStr.includes("_")) val = parseInt(typeStr.split("_")[0], 10);

       if(val===1) counts[idx].j++;
       if(val===2) counts[idx].d++;
       if(val>=3) counts[idx].e++;
    }

    const seriesJ = counts.map(c=>c.j);
    const seriesD = counts.map(c=>c.d);
    const seriesE = counts.map(c=>c.e);

    // Z-Score
    const zJ = zScore(seriesJ);
    const zD = zScore(seriesD);
    const zE = zScore(seriesE);

    // å¹³æ»‘åŒ–
    const smoothJ = movingAvg(zJ, ma);
    const smoothD = movingAvg(zD, ma);
    const smoothE = movingAvg(zE, ma);
    
    // NCI ç¸½åˆ†
    const rawNci = smoothJ.map((v,i) => w1*v + w2*smoothD[i] + w3*smoothE[i]);
    const smoothNci = movingAvg(rawNci, ma); // å†å¹³æ»‘ä¸€æ¬¡ NCI

    // æ­¸ä¸€åŒ–
    const winS = winStart || allDays[0];
    const winE = winEnd || allDays[allDays.length-1];
    const normJ = minMaxNormByWindow(smoothJ, allDays, winS, winE);
    const normD = minMaxNormByWindow(smoothD, allDays, winS, winE);
    const normE = minMaxNormByWindow(smoothE, allDays, winS, winE);
    const normNci = minMaxNormByWindow(smoothNci, allDays, winS, winE);

    return {
      dates: allDays,
      lineJ: shift(normJ, lead),
      lineD: shift(normD, lead),
      lineE: shift(normE, lead),
      lineNci: shift(normNci, lead),
      rawZJ: smoothJ, // ç”¨æ–¼åµæ¸¬
      count: filteredRows.length,
      totJ: seriesJ.reduce((a,b)=>a+b,0),
      totD: seriesD.reduce((a,b)=>a+b,0),
      totE: seriesE.reduce((a,b)=>a+b,0),
      totAll: filteredRows.length,
      wStart: winS, wEnd: winE
    };
  }, [filteredRows, ma, lead, w1, w2, w3, winStart, winEnd, keys]);

  // ğŸ”¥ğŸ”¥ğŸ”¥ è‡ªå‹•åµæ¸¬æå‰é‡ (ä¿®æ­£ç‰ˆï¼šæ—¥æœŸç›¸æ¸›)
  const detectedInfo = useMemo(() => {
    if (!preview || selectedExercise === "å…¨éƒ¨") return null;
    
    const dDayStr = EXERCISE_CONFIG[selectedExercise];
    if (!dDayStr) return { msg: "æœªè¨­å®š D-Day", color: "#999" };

    const THRESHOLD = 1.5;
    const { rawZJ, dates } = preview;
    let triggerDate = "";
    
    for (let i = 0; i < rawZJ.length - 1; i++) {
      if (rawZJ[i] > THRESHOLD && rawZJ[i+1] > THRESHOLD) {
        triggerDate = dates[i];
        break;
      }
    }

    if (!triggerDate) return { msg: "æœªåµæ¸¬åˆ°é¡¯è‘—æ„åœ–è¨Šè™Ÿ (>1.5)", color: "#dc2626" };

    // ä½¿ç”¨æ—¥æœŸç›¸æ¸›
    const diff = getDaysDiff(triggerDate, dDayStr);
    
    return {
      leadDays: diff,
      triggerDate: triggerDate,
      dDay: dDayStr,
      msg: `ç³»çµ±åµæ¸¬æå‰é‡ï¼š${diff} å¤©`,
      detail: `(é è­¦æ—¥ï¼š${triggerDate})`,
      color: diff > 0 ? "#16a34a" : "#dc2626" // å¦‚æœ diff <= 0 (é²å ±) è®Šç´…è‰²
    };
  }, [preview, selectedExercise]);

  // Chart
  function MultiLineChart(props:any){
    const {x, nci, j, d, e} = props;
    if(!x.length) return null;
    const W=800, H=300, pad=30;
    const xs = x.map((_:any,i:number)=> pad + i*(W-2*pad)/(x.length-1));
    const ys = (arr:number[]) => arr.map(v => pad + (H-2*pad)*(1-v)); 
    const path = (arr:number[], c:string) => 
       <path d={xs.map((X:number,i:number)=>`${i===0?'M':'L'} ${X} ${ys(arr)[i]}`).join(" ")} fill="none" stroke={c} strokeWidth={2}/>;
    return (
      <svg viewBox={`0 0 ${W} ${H}`} style={{border:"1px solid #ddd", background:"#fff"}}>
         <text x={pad} y={pad-10} fontSize={10} fill="#666">1.0</text>
         <text x={pad} y={H-pad+15} fontSize={10} fill="#666">0.0</text>
         {props.showJ && path(j, "#16a34a")}
         {props.showD && path(d, "#f59e0b")}
         {props.showE && path(e, "#dc2626")}
         {props.showNci && path(nci, "#2563eb")}
      </svg>
    )
  }
  
  const tableRows = useMemo(()=>{
     if(cleanedRows.length===0) return [];
     const c = selectedExercise==="å…¨éƒ¨" ? cleanedRows : cleanedRows.filter(r=>String(r[keys.kEx]??"").trim()===selectedExercise);
     return c.slice(0, 100);
  }, [cleanedRows, selectedExercise, keys]);

  return (
    <main style={{maxWidth: 1000, margin: "20px auto", fontFamily: "sans-serif", padding: 20}}>
      <h1 style={{fontSize:24, fontWeight:700, marginBottom:10}}>NCIï¼šæˆ°ç•¥é è­¦å›æ¸¬ç³»çµ± (Thesis Ver.)</h1>
      
      {errorMsg && <div style={{background:"#fee", color:"red", padding:10, marginBottom:10}}>{errorMsg}</div>}

      <div style={{marginBottom: 20, padding: 15, background: "#f8fafc", borderRadius: 8, border: "1px solid #e2e8f0"}}>
        <input type="file" onChange={onPickFile} accept=".csv" />
        {loading && <span style={{marginLeft:10}}>Loading...</span>}
      </div>

      <div style={{display:"grid", gridTemplateColumns:"2fr 1fr", gap:20}}>
         <div>
            <label style={{display:"block", marginBottom:5, fontWeight:600}}>é¸æ“‡æ¼”ç¿’ (D-Day è‡ªå‹•è¼‰å…¥)</label>
            <select value={selectedExercise} onChange={e=>setSelectedExercise(e.target.value)} style={{padding:8, width:"100%", borderRadius:4, border:"1px solid #ccc"}}>
               <option value="å…¨éƒ¨">å…¨éƒ¨</option>
               {EXERCISE_ORDER.map(o=><option key={o} value={o}>{o}</option>)}
            </select>
            
            <div style={{marginTop:15, display:"flex", gap:10}}>
              <label>L1æ¬Šé‡ <input type="number" value={w1} onChange={e=>setW1(+e.target.value)} style={{width:50}}/></label>
              <label>L2æ¬Šé‡ <input type="number" value={w2} onChange={e=>setW2(+e.target.value)} style={{width:50}}/></label>
              <label>L3æ¬Šé‡ <input type="number" value={w3} onChange={e=>setW3(+e.target.value)} style={{width:50}}/></label>
              <label>MA <input type="number" value={ma} onChange={e=>setMA(+e.target.value)} style={{width:50}}/></label>
            </div>
         </div>

         {/* ğŸ”¥ è‡ªå‹•åµæ¸¬çµæœé¡¯ç¤º */}
         <div style={{background: "#f0fdf4", padding: 15, borderRadius: 8, border: "2px solid #86efac"}}>
            <label style={{fontWeight: 700, color: "#15803d", display:"block", marginBottom:8}}>
               {/* ä¿®æ­£å¾Œçš„ä»£ç¢¼ï¼šä½¿ç”¨ &gt; å–ä»£ > */}
               ğŸ¤– ç³»çµ±æ¼”ç®—æ³•åµæ¸¬ (L1 &gt; 1.5)
            </label>
            {detectedInfo ? (
               <div>
                  <div style={{fontSize: 18, fontWeight: 800, color: detectedInfo.color}}>
                     {detectedInfo.msg}
                  </div>
                  <div style={{fontSize: 12, color: "#475569", marginTop: 4}}>
                     D-Dayï¼š{detectedInfo.dDay} <br/>
                     {detectedInfo.detail}
                  </div>
               </div>
            ) : (
               <div style={{color:"#999", fontSize:13}}>è«‹é¸æ“‡å–®ä¸€æ¼”ç¿’ä»¥å•Ÿå‹•å›æ¸¬</div>
            )}
            
            <div style={{marginTop:10, paddingTop:10, borderTop:"1px dashed #bbf7d0"}}>
               <label style={{fontSize:12, color:"#166534"}}>æ‰‹å‹•åœ–è¡¨å¹³ç§» (Lead-time)</label>
               <input type="number" value={lead} onChange={e=>setLead(+e.target.value)} style={{width:60, marginLeft:5}}/>
            </div>
         </div>
      </div>

      {preview && (
         <div style={{marginTop: 30}}>
            <div style={{marginBottom:5, fontSize:12, color:"#666", display:"flex", gap:10}}>
               <label><input type="checkbox" checked={showJ} onChange={e=>setShowJ(e.target.checked)}/> æ„åœ–(ç¶ )</label>
               <label><input type="checkbox" checked={showD} onChange={e=>setShowD(e.target.checked)}/> å¨æ‡²(é»ƒ)</label>
               <label><input type="checkbox" checked={showE} onChange={e=>setShowE(e.target.checked)}/> å‡ç´š(ç´…)</label>
               <label><input type="checkbox" checked={showNci} onChange={e=>setShowNci(e.target.checked)}/> NCI(è—)</label>
            </div>
            <MultiLineChart x={preview.dates} nci={preview.lineNci} j={preview.lineJ} d={preview.lineD} e={preview.lineE} 
                            showJ={showJ} showD={showD} showE={showE} showNci={showNci}/>
         </div>
      )}

      {/* ç°¡å–®åˆ—è¡¨ */}
      <div style={{marginTop: 30, borderTop:"1px solid #eee", paddingTop:20}}>
         <h3>è³‡æ–™æª¢è¦– (å‰100ç­†)</h3>
         {tableRows.map((r,i)=>(
            <div key={i} style={{fontSize:12, borderBottom:"1px solid #f1f1f1", padding:"4px 0"}}>
               <span style={{color:"#666", marginRight:10}}>{r[keys.kDate]}</span>
               <span style={{fontWeight:600, marginRight:10}}>{r[keys.kEx]}</span>
               {r[keys.kText]?.slice(0,50)}...
            </div>
         ))}
      </div>
    </main>
  );
}