'use client';

import React, { useMemo, useState } from 'react';

/** =========================================================
 *  0) 你原本的 keywords（保留）
 * ========================================================= */
const KEYWORDS = [
  "台灣","台湾","台海","軍演","演訓","佩洛西","制裁","嚴正","堅決","強烈",
  "導彈","东风","實彈","实弹","行动","行動","嚴重後果","严重后果","維權","維穩"
];

/** =========================================================
 *  1) 你最新的三籃字典（意圖/威懲/升級）
 * ========================================================= */
const BAG_JUSTIFY = [
  "維護","捍衛","堅持","反對","遏制","不承諾放棄","不承諾放棄（武力）","武力","致力於","實現",
  "主權","領土完整","一中原則","九二共識","和平統一","一國兩制","核心利益","民族復興","歷史任務",
  "祖國統一","底線","紅線","基本方針","堅定","堅決","不可動搖","矢志不渝","一貫","明確",
  "正當","合法","堅強","意志","堅強（意志）"
];

const BAG_DETER = [
  "嚴正警告","嚴懲","粉碎","清算","打擊","玩火","自焚","埋葬","挑釁","分裂","勾連","注定失敗",
  "後果自負","死路一條","付出代價","頭破血流","妄想","災難性後果","雷霆之勢","絕不姑息",
  "萬劫不復","歷史罪人","勿謂言之不預","必將","一定會","不得不","不惜一切代價","任何時候","任何形式"
];

const BAG_ESCALATE = [
  "演練","演習","聯合演訓","警巡","戰備","封鎖","實彈射擊","抵近","懾壓","常態化","巡航","越線",
  "立體","全天候","進一步","升級","採取","採取（必要）行動","必要行動","反制","拭目以待","奉陪到底",
  "絕不坐視","反擊","加大","加大（力度）","台島周邊","海空域","越過中線","多軍兵種","全要素",
  "關門打狗","區域拒止"
];

/** =========================================================
 *  2) 只保留這 7 場軍演（下拉選單只顯示這些）
 * ========================================================= */
const EXERCISE_ORDER = [
  "裴洛西訪台",
  "蔡英文訪美",
  "賴清德訪美",
  "聯合利劍A",
  "聯合利劍B",
  "海峽雷霆",
  "正義使命",
];

/** =========================================================
 *  3) 台灣議題斷句用：台灣語彙（只用於「挑出句子」）
 * ========================================================= */
const TAIWAN_LEXICON = [
  "台灣","台湾","臺灣","台海","臺海","台湾地区","台岛","台島",
  "兩岸","两岸","海峽兩岸","海峡两岸","中線","中线","台島周邊","台岛周边"
];

/** ====== 小工具 ====== */
function esc(s: string){ return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }
function uniqStr(arr: string[]) {
  const s = new Set<string>();
  for (const x of arr) {
    const v = String(x || "").trim();
    if (v) s.add(v);
  }
  return Array.from(s);
}
function makeRe(list: string[]){ return new RegExp(uniqStr(list).map(esc).join("|"), "g"); }
function hitCount(re: RegExp, s: string){ return (s.match(re) || []).length; } // 避免 count 命名衝突
function stripBom(s: string){ return s.replace(/^\uFEFF/, ""); }
function toYMD(d: Date){
  return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()))
    .toISOString()
    .slice(0,10);
}
function parseYMD(s: string){
  const t = String(s ?? "").trim().replace(/["']/g,"");
  // 支援 2022/7/5 或 2022-07-05
  const m = t.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/);
  if (!m) return null;
  const d = new Date(Date.UTC(+m[1], +m[2]-1, +m[3]));
  return isNaN(d.getTime()) ? null : d;
}
function addDays(d: Date, n: number){
  const x = new Date(d);
  x.setUTCDate(x.getUTCDate()+n);
  return x;
}
function rangeDays(a: Date, b: Date){
  const out: string[] = [];
  for(let d=new Date(a); d<=b; d=addDays(d,1)) out.push(toYMD(d));
  return out;
}
function movingAvg(arr: number[], k: number){
  if (k<=1) return arr.slice();
  const out: number[] = new Array(arr.length).fill(0);
  let sum = 0;
  for (let i=0;i<arr.length;i++){
    sum += arr[i];
    if (i>=k) sum -= arr[i-k];
    out[i] = i>=k-1 ? sum/k : sum/(i+1);
  }
  return out;
}
function diffAbs(arr: number[]){
  const out = new Array(arr.length).fill(0);
  for(let i=1;i<arr.length;i++) out[i] = Math.abs(arr[i]-arr[i-1]);
  return out;
}
function secondDiffAbs(arr: number[]){
  const d1 = diffAbs(arr);
  return diffAbs(d1);
}
function shift(arr: number[], lead: number){
  const n = arr.length;
  const out = new Array(n).fill(0);
  for(let i=0;i<n;i++){
    const j = i + lead;
    if (j>=0 && j<n) out[i] = arr[j];
  }
  return out;
}
function minMaxNormByWindow(series: number[], dates: string[], winStart: string, winEnd: string){
  let lo = +Infinity, hi = -Infinity;
  for (let i=0;i<dates.length;i++){
    if (dates[i]>=winStart && dates[i]<=winEnd){
      if (series[i]<lo) lo = series[i];
      if (series[i]>hi) hi = series[i];
    }
  }
  if (!isFinite(lo) || !isFinite(hi) || hi===lo) {
    lo = Math.min(...series);
    hi = Math.max(...series);
    if (hi===lo){ return series.map(_=>0.5); }
  }
  const span = hi - lo;
  return series.map(v => Math.max(0, Math.min(1, (v - lo) / span)));
}

/** ====== regex（keywords / 三籃 / 台灣語彙） ====== */
const KW_RE = new RegExp(KEYWORDS.map(esc).join("|"), "g");
const RE_JUSTIFY  = makeRe(BAG_JUSTIFY);
const RE_DETER    = makeRe(BAG_DETER);
const RE_ESCALATE = makeRe(BAG_ESCALATE);
const TW_RE       = makeRe(TAIWAN_LEXICON);

/** ====== 斷句：把 text 拆成句子（中英文標點 + 換行） ====== */
function splitSentences(text: string){
  const s = String(text ?? "")
    .replace(/\r\n/g, "\n")
    .replace(/\s+/g, " ")
    .trim();
  if (!s) return [];
  // 以句末標點切
  const parts = s.split(/(?<=[。！？!?；;])\s+|\n+/g).map(x=>x.trim()).filter(Boolean);
  // 若沒切出來，退回用逗號/頓號粗切
  if (parts.length<=1){
    return s.split(/[，,、]\s*/g).map(x=>x.trim()).filter(Boolean);
  }
  return parts;
}

/** ====== 只取「台灣議題句」：句子需含台灣語彙 ====== */
function taiwanIssueSentences(text: string){
  const sents = splitSentences(text);
  return sents.filter(s => TW_RE.test(s));
}

/** =========================================================
 *  4) 關鍵詞上色（優先順序：升級 > 威懲 > 意圖）
 *     - 同一個詞若重複出現在多籃，只用最高優先的顏色
 * ========================================================= */
type TokCat = 'justify' | 'deter' | 'escalate';
type HiTok = { t: string; cat: TokCat; bg: string; fg: string; prio: number };

const HILITE_TOKENS: HiTok[] = (() => {
  const prio = { escalate: 3, deter: 2, justify: 1 } as const;

  // 先用 map 做「同詞去重 + 依優先順序覆蓋」
  const m = new Map<string, HiTok>();

  const put = (t: string, cat: TokCat) => {
    const token = String(t||"").trim();
    if (!token) return;

    const style =
      cat === 'escalate' ? { bg:'#fee2e2', fg:'#991b1b' } :
      cat === 'deter'    ? { bg:'#fef3c7', fg:'#92400e' } :
                           { bg:'#dcfce7', fg:'#065f46' };

    const cur: HiTok = { t: token, cat, ...style, prio: prio[cat] };
    const old = m.get(token);
    if (!old || cur.prio > old.prio) m.set(token, cur);
  };

  for (const t of BAG_JUSTIFY)  put(t, 'justify');
  for (const t of BAG_DETER)    put(t, 'deter');
  for (const t of BAG_ESCALATE) put(t, 'escalate');

  const all = Array.from(m.values());
  // 長詞優先匹配，避免短詞先吃掉長詞
  all.sort((a,b)=> b.t.length - a.t.length);
  return all;
})();

function highlightSentence3Colors(s: string): React.ReactNode[] {
  const out: React.ReactNode[] = [];
  const text = s || "";
  const n = text.length;
  let i = 0;
  let key = 0;

  const findBestAt = (pos: number): HiTok | null => {
    for (const tok of HILITE_TOKENS) {
      if (text.startsFS.startsWith(tok.t, pos)) return tok;
    }
    return null;
  };

  const findNextMatch = (from: number): number => {
    let next = n;
    for (const tok of HILITE_TOKENS) {
      const j = text.indexOf(tok.t, from);
      if (j !== -1 && j < next) next = j;
    }
    return next;
  };

  // 修正：上面誤植了 text.startsWith；避免 TS/Runtime 問題
  function startsWithAt(str: string, sub: string, pos: number){
    return str.substr(pos, sub.length) === sub;
  }

  const bestAt = (pos:number): HiTok | null => {
    for (const tok of HILITE_TOKENS){
      if (startsWithAt(text, tok.t, pos)) return tok;
    }
    return null;
  };

  while (i < n) {
    const best = bestAt(i);
    if (best) {
      out.push(
        <span
          key={key++}
          style={{
            background: best.bg,
            color: best.fg,
            padding: "0 2px",
            borderRadius: 4,
            margin: "0 1px",
            boxDecorationBreak: "clone",
            WebkitBoxDecorationBreak: "clone",
          }}
        >
          {best.t}
        </span>
      );
      i += best.t.length;
      continue;
    }

    const next = findNextMatch(i + 1);
    const chunk = text.slice(i, next);
    out.push(<span key={key++}>{chunk}</span>);
    i = next;
  }

  return out;
}

/** =========================================================
 *  5) 解析 CSV/TSV（支援引號、BOM、逗號或 Tab 自動偵測）
 * ========================================================= */
function parseTable(text: string): {rows: any[], headers: string[], delim: string}{
  const raw = stripBom(text.replace(/\r\n/g, "\n"));
  const firstLine = raw.split("\n")[0] ?? "";
  const delim = firstLine.includes("\t") ? "\t" : ",";

  const lines = raw.split("\n").filter(l => l.length>0);
  if (lines.length===0) return {rows:[], headers:[], delim};

  const headers = parseLine(lines[0], delim).map(h => stripBom(h).replace(/(^"|"$)/g,""));
  const rows: any[] = [];
  for (let i=1;i<lines.length;i++){
    const cols = parseLine(lines[i], delim);
    if (cols.length===0) continue;
    const obj: any = {};
    for (let j=0;j<headers.length;j++){
      obj[headers[j]] = (cols[j] ?? "").replace(/(^"|"$)/g,"");
    }
    rows.push(obj);
  }
  return {rows, headers, delim};
}
function parseLine(line: string, delim: string){
  const out: string[] = [];
  let cur = "", q = false;
  for (let i=0;i<line.length;i++){
    const c = line[i];
    if (q){
      if (c === '"'){
        if (line[i+1] === '"'){ cur += '"'; i++; }
        else q = false;
      }else cur += c;
    }else{
      if (c === '"') q = true;
      else if (c === delim) { out.push(cur); cur=""; }
      else cur += c;
    }
  }
  out.push(cur);
  return out;
}

/** ====== 型別 ====== */
type F1Mode = 'docs' | 'keywords' | 'chars' | 'intent';

export default function Page(){
  const [fileName, setFileName] = useState<string>("");
  const [rows, setRows]         = useState<any[]>([]);
  const [headers, setHeaders]   = useState<string[]>([]);

  // 參數（維持你原本的）
  const [w1, setW1] = useState(0.4);
  const [w2, setW2] = useState(0.3);
  const [w3, setW3] = useState(0.3);
  const [ma, setMA] = useState(7);
  const [lead, setLead] = useState(0);

  // f1 量度（保留）
  const [f1Mode, setF1Mode] = useState<F1Mode>('docs');

  // 只留 7 場 + 全部
  const [selectedExercise, setSelectedExercise] = useState<string>("全部");

  // 視覺：4 條線可切換
  const [showNci, setShowNci] = useState(true);
  const [showJ, setShowJ]     = useState(true);
  const [showD, setShowD]     = useState(true);
  const [showE, setShowE]     = useState(true);

  // 事件窗（預設用「當前篩選後」資料涵蓋期）
  const [winStart, setWinStart] = useState<string>("");
  const [winEnd,   setWinEnd]   = useState<string>("");

  /** 讀檔 */
  function onPickFile(e: React.ChangeEvent<HTMLInputElement>){
    const f = e.target.files?.[0];
    if (!f) return;
    setFileName(f.name);

    const fr = new FileReader();
    fr.onload = () => {
      const text = typeof fr.result === 'string'
        ? fr.result
        : new TextDecoder("utf-8").decode(fr.result as ArrayBuffer);

      const {rows, headers} = parseTable(text);
      setRows(rows);
      setHeaders(headers);

      // 重置篩選與事件窗，讓 UI 自動用新資料涵蓋期
      setSelectedExercise("全部");
      setWinStart("");
      setWinEnd("");
    };
    fr.readAsText(f);
  }

  /** 欄位偵測：所屬軍演 / date / source / text / link */
  const keys = useMemo(()=>{
    const kEx   = findKeyFromArray(rows, ["所屬軍演","军演","事件","event","exercise","exercise_name","campaign"]);
    const kDate = findKeyFromArray(rows, ["date","日期"]);
    const kSrc  = findKeyFromArray(rows, ["source","來源","source_name"]);
    const kText = findKeyFromArray(rows, ["text","內容","content","文本"]);
    const kLink = findKeyFromArray(rows, ["Link","link","URL","url"]);
    return { kEx, kDate, kSrc, kText, kLink };
  },[rows]);

  /** 只保留 7 場軍演資料（「全部」也只看這 7 場，符合你「只留那 7 場」） */
  const cleanedRows = useMemo(()=>{
    if (rows.length===0) return [];
    const set7 = new Set(EXERCISE_ORDER);
    const {kEx} = keys;
    return rows.filter(r => set7.has(String(r[kEx] ?? "").trim()));
  }, [rows, keys]);

  /** 篩選：全部 / 單一軍演 */
  const filteredRows = useMemo(()=>{
    if (cleanedRows.length===0) return [];
    if (selectedExercise === "全部") return cleanedRows;
    const {kEx} = keys;
    return cleanedRows.filter(r => String(r[kEx] ?? "").trim() === selectedExercise);
  }, [cleanedRows, selectedExercise, keys]);

  /** 下拉選單：固定只顯示 7 場（不從資料擴充） */
  const exerciseOptions = useMemo(()=>{
    return ["全部", ...EXERCISE_ORDER];
  }, []);

  /** 以「篩選後」資料計算涵蓋期 */
  const {minDateStr, maxDateStr} = useMemo(()=>{
    const ds: Date[] = [];
    for (const r of filteredRows){
      const raw = String(r[keys.kDate] ?? "");
      const d = parseYMD(raw);
      if (d) ds.push(d);
    }
    if (ds.length===0) return {minDateStr:"", maxDateStr:""};
    ds.sort((a,b)=>+a-+b);
    return {minDateStr: toYMD(ds[0]), maxDateStr: toYMD(ds[ds.length-1])};
  }, [filteredRows, keys]);

  /** 切換軍演：清空事件窗，讓日期自動跟著該軍演涵蓋期 */
  function onChangeExercise(v: string){
    setSelectedExercise(v);
    setWinStart("");
    setWinEnd("");
  }

  /** 核心計算：日序列 + 4 條線（J/D/E/NCI） */
  const preview = useMemo(()=>{
    if (filteredRows.length===0) return null;

    const kDate = keys.kDate;
    const kText = keys.kText;
    const kSrc  = keys.kSrc;

    // 先抓日期範圍
    let dmin: Date|undefined, dmax: Date|undefined;
    for (const r of filteredRows){
      const d = parseYMD(String(r[kDate] ?? ""));
      if (!d) continue;
      dmin = dmin ? (d<dmin?d:dmin) : d;
      dmax = dmax ? (d>dmax?d:dmax) : d;
    }
    if (!dmin || !dmax) return null;

    const days = rangeDays(dmin, dmax);

    // 每日加總：J/D/E、keywords、chars、docs
    const mapJ = new Map<string, number>();
    const mapD = new Map<string, number>();
    const mapE = new Map<string, number>();
    const mapKW = new Map<string, number>();
    const mapCh = new Map<string, number>();
    const mapDocs = new Map<string, number>();

    for (const r of filteredRows){
      const d = parseYMD(String(r[kDate] ?? ""));
      if (!d) continue;
      const day = toYMD(d);

      const txt = ((r[kText] ?? "") + " " + (r[kSrc] ?? "")).toString();

      const j = hitCount(RE_JUSTIFY, txt);
      const dh = hitCount(RE_DETER, txt);
      const e  = hitCount(RE_ESCALATE, txt);

      mapJ.set(day, (mapJ.get(day)||0) + j);
      mapD.set(day, (mapD.get(day)||0) + dh);
      mapE.set(day, (mapE.get(day)||0) + e);

      mapKW.set(day, (mapKW.get(day)||0) + (txt.match(KW_RE)||[]).length);
      mapCh.set(day, (mapCh.get(day)||0) + (txt.length/1000));
      mapDocs.set(day, (mapDocs.get(day)||0) + 1);
    }

    const seriesJ = days.map(d=>mapJ.get(d)||0);
    const seriesD = days.map(d=>mapD.get(d)||0);
    const seriesE = days.map(d=>mapE.get(d)||0);

    // NCI 的 f1：看你下拉選單
    const f1 = days.map(d=>{
      if (f1Mode==='docs') return mapDocs.get(d)||0;
      if (f1Mode==='chars') return mapCh.get(d)||0;
      if (f1Mode==='keywords') return mapKW.get(d)||0;
      // intent：三籃總和
      return (mapJ.get(d)||0) + (mapD.get(d)||0) + (mapE.get(d)||0);
    });

    // f2/f3（基於 f1）
    const f2 = diffAbs(f1);
    const f3 = secondDiffAbs(f1);

    // 平滑
    const sJ = movingAvg(seriesJ, ma);
    const sD = movingAvg(seriesD, ma);
    const sE = movingAvg(seriesE, ma);

    const s1 = movingAvg(f1, ma);
    const s2 = movingAvg(f2, ma);
    const s3 = movingAvg(f3, ma);

    // 合成 NCI
    const mix = s1.map((_,i)=> w1*s1[i] + w2*s2[i] + w3*s3[i]);

    const wStart = (winStart||minDateStr||days[0]);
    const wEnd   = (winEnd  ||maxDateStr||days[days.length-1]);

    // 正規化（都用同一事件窗）
    const nci0 = minMaxNormByWindow(mix, days, wStart, wEnd);
    const j0   = minMaxNormByWindow(sJ,  days, wStart, wEnd);
    const d0   = minMaxNormByWindow(sD,  days, wStart, wEnd);
    const e0   = minMaxNormByWindow(sE,  days, wStart, wEnd);

    // lead-time：四條線一起 shift（你要看「前移」時比較一致）
    const nci = shift(nci0, lead);
    const jN  = shift(j0, lead);
    const dN  = shift(d0, lead);
    const eN  = shift(e0, lead);

    // 總命中（統計用）
    const totJ = seriesJ.reduce((a,b)=>a+b,0);
    const totD = seriesD.reduce((a,b)=>a+b,0);
    const totE = seriesE.reduce((a,b)=>a+b,0);
    const totAll = totJ + totD + totE;

    return {
      dates: days,
      cover: `${toYMD(dmin)} ~ ${toYMD(dmax)}`,
      count: filteredRows.length,

      // 四條線
      lineNci: nci,
      lineJ: jN,
      lineD: dN,
      lineE: eN,

      // 統計
      totJ, totD, totE, totAll,

      // 用於 table 顯示
      wStart, wEnd,
    };
  }, [filteredRows, keys, f1Mode, ma, lead, w1, w2, w3, winStart, winEnd, minDateStr, maxDateStr]);

  /** Top-10：各籃詞的命中次數（在目前篩選後的資料上算） */
  const top10 = useMemo(()=>{
    if (filteredRows.length===0) return null;

    const textAll = filteredRows
      .map(r => `${r[keys.kText] ?? ""} ${r[keys.kSrc] ?? ""}`)
      .join("\n");

    const countPerToken = (tokens: string[]) => {
      const uniq = uniqStr(tokens).sort((a,b)=>b.length-a.length);
      const arr = uniq.map(t=>{
        const re = new RegExp(esc(t), "g");
        const c = (textAll.match(re) || []).length;
        return { t, c };
      }).filter(x=>x.c>0);
      arr.sort((a,b)=>b.c-a.c);
      return arr.slice(0,10);
    };

    return {
      J: countPerToken(BAG_JUSTIFY),
      D: countPerToken(BAG_DETER),
      E: countPerToken(BAG_ESCALATE),
    };
  }, [filteredRows, keys]);

  /** 下載 NCI CSV（只輸出日期與 NCI） */
  function downloadNciCsv(){
    if (!preview) return;
    const lines = ["date,nci"];
    for (let i=0;i<preview.dates.length;i++){
      lines.push(`${preview.dates[i]},${preview.lineNci[i].toFixed(6)}`);
    }
    const csv = "\uFEFF" + lines.join("\r\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "nci_result.csv";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  /** 圖：四條線（可勾選顯示）＋ X 軸日期刻度 ＋ Y 軸說明 */
  function MultiLineChart(props: {
    x: string[];
    nci: number[];
    j: number[];
    d: number[];
    e: number[];
    showNci: boolean;
    showJ: boolean;
    showD: boolean;
    showE: boolean;
  }){
    const {x, nci, j, d, e, showNci, showJ, showD, showE} = props;
    if (!x.length) return null;

    const W=1000, H=360, pad=36;
    const xs = x.map((_,i)=> pad + i*(W-2*pad)/Math.max(1,x.length-1));

    const minY=0, maxY=1;
    const yMap = (arr:number[]) => arr.map(v => pad + (H-2*pad)*(1-(v-minY)/(maxY-minY)));

    const toPath = (arr:number[]) => {
      const ys = yMap(arr);
      return xs.map((X,i)=> `${i===0?"M":"L"} ${X.toFixed(1)} ${ys[i].toFixed(1)}`).join(" ");
    };

    // 刻度：<=14 天每日；否則 6~9 個
    let tickCount = x.length <= 14 ? x.length : Math.min(9, Math.max(6, Math.floor((W-2*pad)/120)));
    if (x.length === 1) tickCount = 1;
    const idxCand: number[] = [];
    for (let k=0; k<tickCount; k++){
      const i = (tickCount===1) ? 0 : Math.round(k*(x.length-1)/(tickCount-1));
      idxCand.push(i);
    }
    const seen = new Set<number>();
    const xticks = idxCand.filter(i => (seen.has(i)? false : (seen.add(i), true)));

    // 顏色（照你指定）
    const C_NCI = "#2563eb";  // 藍
    const C_J   = "#16a34a";  // 綠
    const C_D   = "#f59e0b";  // 黃
    const C_E   = "#dc2626";  // 紅

    return (
      <svg width="100%" viewBox={`0 0 ${W} ${H}`} style={{border:"1px solid #eee", background:"#fff"}}>
        <rect x={0} y={0} width={W} height={H} fill="#fff"/>

        {/* Y grid */}
        {[0,0.25,0.5,0.75,1].map((g,idx)=>{
          const Y = pad + (H-2*pad)*(1-g);
          return (
            <g key={idx}>
              <line x1={pad} y1={Y} x2={W-pad} y2={Y} stroke="#eee"/>
              <text x={pad-10} y={Y+4} fontSize="10" textAnchor="end">{g.toFixed(2)}</text>
            </g>
          );
        })}

        {/* axes */}
        <line x1={pad} y1={pad} x2={pad} y2={H-pad} stroke="#333"/>
        <line x1={pad} y1={H-pad} x2={W-pad} y2={H-pad} stroke="#333"/>

        {/* X ticks */}
        {xticks.map((i,idx)=>{
          const X = xs[i];
          return (
            <g key={idx}>
              <line x1={X} y1={H-pad} x2={X} y2={H-pad+6} stroke="#333"/>
              <text x={X} y={H-pad+20} fontSize="10" textAnchor="middle">{x[i]}</text>
            </g>
          );
        })}

        {/* Y label */}
        <text x={14} y={H/2} transform={`rotate(-90, 14, ${H/2})`} fontSize="12" fill="#333">
          值（0..1；事件窗內相對化）
        </text>

        {/* lines */}
        {showJ && <path d={toPath(j)}   fill="none" stroke={C_J}   strokeWidth={2} />}
        {showD && <path d={toPath(d)}   fill="none" stroke={C_D}   strokeWidth={2} />}
        {showE && <path d={toPath(e)}   fill="none" stroke={C_E}   strokeWidth={2} />}
        {showNci && <path d={toPath(nci)} fill="none" stroke={C_NCI} strokeWidth={2.5} />}

        {/* legend */}
        <g>
          <rect x={W-pad-330} y={pad-22} width={320} height={18} fill="#fff" opacity={0.9}/>
          <text x={W-pad-320} y={pad-8} fontSize="11" fill="#333">
            {showJ ? "意圖(綠)  " : ""}
            {showD ? "威懲(黃)  " : ""}
            {showE ? "升級(紅)  " : ""}
            {showNci ? "NCI(藍)" : ""}
          </text>
        </g>
      </svg>
    );
  }

  const count = preview?.count ?? 0;
  const cover = preview?.cover ?? "~";

  /** 全部列出：依日期排序（用於表格） */
  const tableRows = useMemo(()=>{
    if (filteredRows.length===0) return [];
    const kDate = keys.kDate;
    const arr = filteredRows.slice();
    arr.sort((a,b)=>{
      const da = parseYMD(String(a[kDate]??""))?.getTime() ?? 0;
      const db = parseYMD(String(b[kDate]??""))?.getTime() ?? 0;
      return da - db;
    });
    return arr;
  }, [filteredRows, keys]);

  return (
    <main style={styles.main}>
      <h1 style={styles.h1}>NCI：上傳資料並分析（含意圖/威懲/升級上色斷句）</h1>

      <div style={{margin:"8px 0"}}>
        <input type="file" accept=".csv,.tsv,text/csv,text/tab-separated-values" onChange={onPickFile}/>
        {fileName && <span style={{marginLeft:12, color:"#555"}}>{fileName}</span>}
      </div>

      {/* 軍演選擇：只顯示 7 場 */}
      <div style={{margin:"10px 0 8px"}}>
        <label>所屬軍演：
          <select
            value={selectedExercise}
            onChange={e=>onChangeExercise(e.target.value)}
            style={{...styles.ibox, width:320, marginLeft:6}}
          >
            {exerciseOptions.map(op => (
              <option key={op} value={op}>{op}</option>
            ))}
          </select>
        </label>
        <span style={{marginLeft:10, color:"#666", fontSize:12}}>
          「全部」也只保留你指定的 7 場軍演資料（其餘值直接忽略）。
        </span>
      </div>

      <div style={{display:"flex", gap:40, flexWrap:"wrap", margin:"8px 0"}}>
        <div>
          <div style={{color:"#666"}}>筆數</div>
          <div style={{fontSize:22, fontWeight:600}}>{count}</div>
        </div>
        <div>
          <div style={{color:"#666"}}>涵蓋</div>
          <div style={{fontSize:18}}>{cover}</div>
        </div>
      </div>

      {/* 參數 */}
      <div style={styles.grid3}>
        <label>MA 天數
          <input type="number" value={ma} onChange={e=>setMA(+e.target.value||0)} style={styles.ibox}/>
        </label>
        <label>Lead-time（日）
          <input type="number" value={lead} onChange={e=>setLead(parseInt(e.target.value||"0"))} style={styles.ibox}/>
        </label>
        <div/>

        <label>事件窗起
          <input type="date" value={winStart||minDateStr} onChange={e=>setWinStart(e.target.value)} style={styles.ibox}/>
        </label>
        <label>事件窗訖
          <input type="date" value={winEnd||maxDateStr} onChange={e=>setWinEnd(e.target.value)} style={styles.ibox}/>
        </label>
        <div/>

        <label>權重 f1（量/強度）
          <input type="number" step="0.1" value={w1} onChange={e=>setW1(+e.target.value||0)} style={styles.ibox}/>
        </label>
        <label>權重 f2（變化）
          <input type="number" step="0.1" value={w2} onChange={e=>setW2(+e.target.value||0)} style={styles.ibox}/>
        </label>
        <label>權重 f3（加速度）
          <input type="number" step="0.1" value={w3} onChange={e=>setW3(+e.target.value||0)} style={styles.ibox}/>
        </label>
      </div>

      {/* f1 量度（保留） */}
      <div style={{marginTop:8}}>
        <label>f1 量度：
          <select
            value={f1Mode}
            onChange={e=>setF1Mode(e.target.value as F1Mode)}
            style={{...styles.ibox, width:320, marginLeft:6}}
          >
            <option value="docs">每天文件數（docs）</option>
            <option value="keywords">關鍵詞命中數（keywords）</option>
            <option value="chars">文字長度（千字，chars）</option>
            <option value="intent">意圖詞庫命中（intent：三籃總和）</option>
          </select>
        </label>
        <div style={{marginTop:4, color:"#666", fontSize:12}}>
          intent 模式使用你最新的三籃字典；同時圖上仍可顯示「意圖/威懲/升級」三條線做對照。
        </div>
      </div>

      {/* 線條顯示切換 */}
      <div style={{marginTop:10, display:"flex", gap:14, flexWrap:"wrap", alignItems:"center"}}>
        <span style={{color:"#666"}}>顯示線條：</span>
        <label><input type="checkbox" checked={showJ} onChange={e=>setShowJ(e.target.checked)} /> 意圖（綠）</label>
        <label><input type="checkbox" checked={showD} onChange={e=>setShowD(e.target.checked)} /> 威懲（黃）</label>
        <label><input type="checkbox" checked={showE} onChange={e=>setShowE(e.target.checked)} /> 升級（紅）</label>
        <label><input type="checkbox" checked={showNci} onChange={e=>setShowNci(e.target.checked)} /> NCI（藍）</label>

        <button onClick={downloadNciCsv} disabled={!preview} style={{...styles.btn, marginLeft:"auto"}}>
          下載 NCI CSV（date,nci）
        </button>
      </div>

      <h2 style={{marginTop:16}}>指數圖（0..1）</h2>
      {preview && (
        <MultiLineChart
          x={preview.dates}
          nci={preview.lineNci}
          j={preview.lineJ}
          d={preview.lineD}
          e={preview.lineE}
          showNci={showNci}
          showJ={showJ}
          showD={showD}
          showE={showE}
        />
      )}

      {/* 三籃統計：命中總數 + 比例 */}
      {preview && (
        <section style={{marginTop:14}}>
          <h3 style={{margin:"10px 0 6px"}}>三籃關鍵詞統計（目前篩選後資料）</h3>
          <div style={{display:"grid", gridTemplateColumns:"repeat(4, 1fr)", gap:12}}>
            <div style={styles.card}>
              <div style={styles.cardLabel}>意圖 命中</div>
              <div style={styles.cardValue}>{preview.totJ}</div>
              <div style={styles.cardNote}>比例：{preview.totAll ? ((preview.totJ/preview.totAll)*100).toFixed(1) : "0.0"}%</div>
            </div>
            <div style={styles.card}>
              <div style={styles.cardLabel}>威懲 命中</div>
              <div style={styles.cardValue}>{preview.totD}</div>
              <div style={styles.cardNote}>比例：{preview.totAll ? ((preview.totD/preview.totAll)*100).toFixed(1) : "0.0"}%</div>
            </div>
            <div style={styles.card}>
              <div style={styles.cardLabel}>升級 命中</div>
              <div style={styles.cardValue}>{preview.totE}</div>
              <div style={styles.cardNote}>比例：{preview.totAll ? ((preview.totE/preview.totAll)*100).toFixed(1) : "0.0"}%</div>
            </div>
            <div style={styles.card}>
              <div style={styles.cardLabel}>三籃合計</div>
              <div style={styles.cardValue}>{preview.totAll}</div>
              <div style={styles.cardNote}>事件窗：{preview.wStart} ～ {preview.wEnd}</div>
            </div>
          </div>
        </section>
      )}

      {/* Top-10（各類別） */}
      {top10 && (
        <section style={{marginTop:14}}>
          <h3 style={{margin:"10px 0 6px"}}>關鍵詞 Top-10（各類別，命中次數）</h3>
          <div style={{display:"grid", gridTemplateColumns:"repeat(3, 1fr)", gap:12}}>
            <div style={styles.card}>
              <div style={{...styles.cardLabel, color:"#065f46"}}>意圖（綠）</div>
              <ol style={{margin:"8px 0 0 18px"}}>
                {top10.J.map(x => <li key={x.t}><span>{x.t}</span> <span style={{color:"#666"}}>({x.c})</span></li>)}
              </ol>
            </div>
            <div style={styles.card}>
              <div style={{...styles.cardLabel, color:"#92400e"}}>威懲（黃）</div>
              <ol style={{margin:"8px 0 0 18px"}}>
                {top10.D.map(x => <li key={x.t}><span>{x.t}</span> <span style={{color:"#666"}}>({x.c})</span></li>)}
              </ol>
            </div>
            <div style={styles.card}>
              <div style={{...styles.cardLabel, color:"#991b1b"}}>升級（紅）</div>
              <ol style={{margin:"8px 0 0 18px"}}>
                {top10.E.map(x => <li key={x.t}><span>{x.t}</span> <span style={{color:"#666"}}>({x.c})</span></li>)}
              </ol>
            </div>
          </div>
        </section>
      )}

      {/* 全部列出（日期＋台灣議題斷句，上色） */}
      <section style={{marginTop:16}}>
        <h3 style={{margin:"10px 0 6px"}}>全部列出（日期＋台灣議題斷句；三籃關鍵詞以綠/黃/紅標示）</h3>

        <div style={{border:"1px solid #eee", borderRadius:10, overflow:"hidden"}}>
          <div style={{maxHeight:560, overflow:"auto"}}>
            <table style={{width:"100%", borderCollapse:"collapse"}}>
              <thead style={{position:"sticky", top:0, zIndex:2}}>
                <tr>
                  <th style={styles.th}>日期</th>
                  <th style={styles.th}>所屬軍演</th>
                  <th style={styles.th}>來源</th>
                  <th style={styles.th}>台灣議題斷句（上色）</th>
                </tr>
              </thead>
              <tbody>
                {tableRows.map((r, idx)=>{
                  const date = String(r[keys.kDate] ?? "");
                  const ex   = String(r[keys.kEx] ?? "");
                  const src  = String(r[keys.kSrc] ?? "");
                  const txt  = String(r[keys.kText] ?? "");
                  const sents = taiwanIssueSentences(txt);

                  return (
                    <tr key={idx}>
                      <td style={styles.tdSmall}>{date}</td>
                      <td style={styles.tdSmall}>{ex}</td>
                      <td style={styles.tdSmall}>{src}</td>
                      <td style={styles.td}>
                        {sents.length ? (
                          <div style={{lineHeight:1.6}}>
                            {sents.map((s,i)=>(
                              <div key={i} style={{whiteSpace:"pre-wrap", marginBottom:6}}>
                                <span style={{color:"#666"}}>({i+1}) </span>
                                <span>{highlightSentence3Colors(s)}</span>
                              </div>
                            ))}
                          </div>
                        ) : (
                          <span style={{color:"#999"}}>（無台灣語彙句）</span>
                        )}
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>

        <div style={{marginTop:8, color:"#666", fontSize:12}}>
          顏色規則（優先順序）：升級（紅） &gt; 威懲（黃） &gt; 意圖（綠）。同一詞若同時存在多籃，只用最高優先顏色顯示。
        </div>
      </section>
    </main>
  );
}

/** ====== 樣式 ====== */
const styles: Record<string, React.CSSProperties> = {
  main: {
    maxWidth: 1150,
    margin: "20px auto",
    padding: "0 16px",
    fontFamily: "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,'Noto Sans TC',sans-serif"
  },
  h1: { fontSize: 24, fontWeight: 700, marginBottom: 8 },
  grid3: { display:"grid", gridTemplateColumns:"repeat(3, 1fr)", gap:14, marginTop:10 },
  ibox: { display:"block", width:180, marginTop:4, padding:"6px 8px", border:"1px solid #ddd", borderRadius:6 },
  btn:  { padding:"8px 14px", border:"1px solid #ddd", borderRadius:8, background:"#fff", cursor:"pointer" },
  th:   { textAlign:"left", borderBottom:"1px solid #eee", padding:"8px 8px", background:"#fafafa", fontWeight:700, fontSize:13 },
  td:   { borderBottom:"1px solid #f2f2f2", verticalAlign:"top", padding:"8px 8px", fontSize:14 },
  tdSmall: { borderBottom:"1px solid #f2f2f2", verticalAlign:"top", padding:"8px 8px", fontSize:13, color:"#333", whiteSpace:"nowrap" },
  card: { border:"1px solid #eee", borderRadius:10, padding:"10px 12px", background:"#fff" },
  cardLabel: { fontSize:12, color:"#666" },
  cardValue: { fontSize:22, fontWeight:700, marginTop:4 },
  cardNote: { fontSize:12, color:"#666", marginTop:2 },
};

/** ====== 欄位 key 尋找 ====== */
function findKey(obj:any, cands:string[]){
  const keys = Object.keys(obj).map(k=>stripBom(k));
  for (const c of cands){
    const hit = keys.find(k => k.toLowerCase()===c.toLowerCase());
    if (hit) return hit;
  }
  return null;
}
function findKeyFromArray(rows:any[], cands:string[]){
  for (const r of rows){
    const k = findKey(r, cands);
    if (k) return k;
  }
  // 找不到就回傳第一個候選（避免 undefined）
  return cands[0];
}
